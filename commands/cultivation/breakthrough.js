const { getLevelByName, getNextLevel, canBreakthrough, rollBreakthrough, applyBreakthroughPenalty, formatRequirements, checkBreakthroughRequirements, consumeBreakthroughRequirements, ensureRoleExists } = require('../../utils/cultivationData');
const { EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle, ComponentType } = require('discord.js');

module.exports = {
    name: 'breakthrough',
    aliases: ['dotpha', 'bt'],
    description: 'Th·ª≠ ƒë·ªôt ph√° l√™n level cao h∆°n (c·∫ßn ƒëan d∆∞·ª£c/linh th·∫°ch trong t√∫i)',
    usage: '!breakthrough',
    examples: [
        '!breakthrough',
        '!dotpha',
        '!bt'
    ],
    permissions: 'everyone',
    guildOnly: true,
    category: 'cultivation',

    async execute(message, args, client) {
        try {
            const userId = message.author.id;
            const guildId = message.guild.id;

            // Get user data
            const cultivationUser = await client.prisma.cultivationUser.findUnique({
                where: {
                    userId: userId
                }
            });

            if (!cultivationUser) {
                return message.reply('‚ùå B·∫°n c·∫ßn b·∫Øt ƒë·∫ßu tu luy·ªán tr∆∞·ªõc! G·ª≠i tin nh·∫Øn trong server ƒë·ªÉ b·∫Øt ƒë·∫ßu nh·∫≠n EXP.');
            }

            // Check if can breakthrough
            if (!canBreakthrough(cultivationUser.currentLevel, cultivationUser.exp)) {
                const currentLevelData = getLevelByName(cultivationUser.currentLevel);
                const expNeeded = currentLevelData ? currentLevelData.exp - cultivationUser.exp : 0;

                return message.reply(`‚ùå **${message.author.username}** c·∫ßn th√™m **${expNeeded} exp** ƒë·ªÉ c√≥ th·ªÉ ƒë·ªôt ph√°! *(Hi·ªán t·∫°i: ${cultivationUser.exp}/${currentLevelData?.exp || 'N/A'})*`);
            }

            const currentLevelData = getLevelByName(cultivationUser.currentLevel);
            const nextLevelData = getNextLevel(cultivationUser.currentLevel);

            if (!nextLevelData) {
                return message.reply('üèÜ **B·∫°n ƒë√£ ƒë·∫°t ƒë·∫øn ƒë·ªânh cao c·ªßa tu luy·ªán!**');
            }

            // Check breakthrough requirements
            const requirementCheck = await checkBreakthroughRequirements(client, userId, nextLevelData);
            
            if (!requirementCheck.canBreakthrough) {
                const missingText = requirementCheck.missingItems.map(item => 
                    `${item.icon} **${item.name}**: C·∫ßn \`${item.needed}\`, c√≥ \`${item.have}\``
                ).join('\n');

                const errorEmbed = new EmbedBuilder()
                    .setTitle('‚ùå Kh√¥ng ƒë·ªß ƒëi·ªÅu ki·ªán ƒë·ªôt ph√°!')
                    .setDescription(`**${message.author.username}** ch∆∞a ƒë·ªß y√™u c·∫ßu ƒë·ªÉ ƒë·ªôt ph√° l√™n **${nextLevelData.name}**`)
                    .setColor(0xff4444)
                    .addFields({
                        name: 'üì¶ Thi·∫øu trong t√∫i ƒë·ªì',
                        value: missingText,
                        inline: false
                    })
                    .setTimestamp()
                    .setFooter({ 
                        text: `Breakthrough ‚Ä¢ ${message.author.username}`, 
                        iconURL: message.author.displayAvatarURL() 
                    });

                return message.reply({ embeds: [errorEmbed] });
            }

            // Create confirmation embed based on risk level
            const requirementsText = formatRequirements(nextLevelData);
            const hasRisk = currentLevelData.expPenalty > 0 || currentLevelData.itemPenalty > 0;

            const confirmEmbed = new EmbedBuilder()
                .setTitle(hasRisk ? '‚ö†Ô∏è C·∫£nh B√°o ƒê·ªôt Ph√°' : 'üéØ ƒê·ªôt Ph√° An To√†n')
                .setDescription(`**${message.author.username}** mu·ªën ƒë·ªôt ph√° l√™n **${nextLevelData.name}**`)
                .setColor(hasRisk ? 0xff4444 : 0x00ff88)
                .addFields([
                    {
                        name: 'üìä Th√¥ng tin ƒë·ªôt ph√°',
                        value: `‚Ä¢ **Level hi·ªán t·∫°i:** ${cultivationUser.currentLevel}\n‚Ä¢ **Level m·ª•c ti√™u:** ${nextLevelData.name}\n‚Ä¢ **T·ªâ l·ªá th√†nh c√¥ng:** **${currentLevelData.breakRate}%**\n‚Ä¢ **EXP hi·ªán t·∫°i:** ${cultivationUser.exp.toLocaleString()}`,
                        inline: false
                    },
                    {
                        name: 'üíé V·∫≠t ph·∫©m s·∫Ω ti√™u t·ªën',
                        value: requirementsText,
                        inline: false
                    }
                ])
                .setTimestamp()
                .setFooter({ 
                    text: `Breakthrough ‚Ä¢ ${message.author.username}`, 
                    iconURL: message.author.displayAvatarURL() 
                });

            if (hasRisk) {
                confirmEmbed.addFields({
                    name: 'üíÄ Nguy c∆° n·∫øu th·∫•t b·∫°i',
                    value: `‚Ä¢ M·∫•t **1-10%** EXP hi·ªán t·∫°i (random)\n‚Ä¢ M·∫•t **${currentLevelData.itemPenalty}** v·∫≠t ph·∫©m ng·∫´u nhi√™n\n‚Ä¢ **V·∫≠t ph·∫©m y√™u c·∫ßu v·∫´n b·ªã ti√™u t·ªën d√π th·∫•t b·∫°i**`,
                    inline: false
                });
            } else {
                confirmEmbed.addFields({
                    name: 'üíö An to√†n',
                    value: 'Kh√¥ng c√≥ r·ªßi ro m·∫•t EXP hay v·∫≠t ph·∫©m (ch·ªâ ti√™u t·ªën v·∫≠t ph·∫©m y√™u c·∫ßu)',
                    inline: false
                });
            }

            const confirmButtons = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('breakthrough_confirm')
                        .setLabel('‚ö° X√°c nh·∫≠n ƒë·ªôt ph√°')
                        .setStyle(hasRisk ? ButtonStyle.Danger : ButtonStyle.Success),
                    new ButtonBuilder()
                        .setCustomId('breakthrough_cancel')
                        .setLabel('‚ùå H·ªßy b·ªè')
                        .setStyle(ButtonStyle.Secondary)
                );

            const reply = await message.reply({ 
                embeds: [confirmEmbed], 
                components: [confirmButtons] 
            });

            // Handle button interactions
            const collector = reply.createMessageComponentCollector({
                componentType: ComponentType.Button,
                time: 60000, // 1 minute
                filter: i => i.user.id === message.author.id
            });

            collector.on('collect', async interaction => {
                if (interaction.customId === 'breakthrough_confirm') {
                    await this.performBreakthrough(interaction, client, userId, currentLevelData, nextLevelData, cultivationUser);
                } else if (interaction.customId === 'breakthrough_cancel') {
                    const cancelEmbed = new EmbedBuilder()
                        .setTitle('‚ùå ƒê√£ h·ªßy ƒë·ªôt ph√°')
                        .setDescription('Qu√° tr√¨nh ƒë·ªôt ph√° ƒë√£ b·ªã h·ªßy.')
                        .setColor(0xff4444)
                        .setTimestamp()
                        .setFooter({ 
                            text: `Breakthrough ‚Ä¢ ${message.author.username}`, 
                            iconURL: message.author.displayAvatarURL() 
                        });

                    await interaction.update({ 
                        embeds: [cancelEmbed], 
                        components: [] 
                    });
                }
            });

            collector.on('end', () => {
                // Disable buttons when expired
                const disabledButtons = new ActionRowBuilder()
                    .addComponents(
                        new ButtonBuilder()
                            .setCustomId('breakthrough_confirm')
                            .setLabel('‚ö° X√°c nh·∫≠n ƒë·ªôt ph√°')
                            .setStyle(hasRisk ? ButtonStyle.Danger : ButtonStyle.Success)
                            .setDisabled(true),
                        new ButtonBuilder()
                            .setCustomId('breakthrough_cancel')
                            .setLabel('‚ùå H·ªßy b·ªè')
                            .setStyle(ButtonStyle.Secondary)
                            .setDisabled(true)
                    );
                
                reply.edit({ components: [disabledButtons] }).catch(() => {});
            });

            return; // Exit early since we're handling the breakthrough in the collector

        } catch (error) {
            console.error('Error in breakthrough command:', error);
            await message.reply(`‚ùå L·ªói ƒë·ªôt ph√°: ${error.message}`);
        }
    },

    async performBreakthrough(interaction, client, userId, currentLevelData, nextLevelData, cultivationUser) {
        try {
            // Consume requirements first (regardless of success/failure)
            const consumedItems = await consumeBreakthroughRequirements(client, userId, nextLevelData);

            // Attempt breakthrough
            const success = rollBreakthrough(currentLevelData.breakRate);

            if (success) {
                // Success - Update level
                await client.prisma.cultivationUser.update({
                    where: {
                        userId: userId
                    },
                    data: {
                        currentLevel: nextLevelData.name
                    }
                });

                // Try to manage roles (remove old, add new if different)
                try {
                    // Ensure new role exists
                    const newRole = await ensureRoleExists(interaction.guild, nextLevelData.role);
                    
                    if (newRole) {
                        // Convert level names to role names  
                        const currentRoleName = currentLevelData.role;
                        const newRoleName = nextLevelData.role;
                        
                        // Only change roles if they're different
                        if (currentRoleName !== newRoleName) {
                            // Remove old role
                            const oldRole = interaction.guild.roles.cache.find(r => r.name === currentRoleName);
                            if (oldRole && interaction.member.roles.cache.has(oldRole.id)) {
                                await interaction.member.roles.remove(oldRole);
                                console.log(`üóëÔ∏è ƒê√£ x√≥a role c≈© "${oldRole.name}" c·ªßa ${interaction.user.username}`);
                            }
                            
                            // Add new role
                            if (newRole.position >= interaction.guild.members.me.roles.highest.position) {
                                console.log(`‚ùå Role "${newRole.name}" c√≥ th·ª© t·ª± cao h∆°n bot`);
                                await interaction.followUp(`‚ö†Ô∏è Bot kh√¥ng th·ªÉ g√°n role **${newRole.name}** v√¨ role n√†y c√≥ th·ª© t·ª± cao h∆°n bot!`);
                            } else {
                                await interaction.member.roles.add(newRole);
                                console.log(`‚úÖ ƒê√£ g√°n role m·ªõi "${newRole.name}" cho ${interaction.user.username}`);
                            }
                        } else {
                            console.log(`‚ÑπÔ∏è Role kh√¥ng thay ƒë·ªïi: "${newRoleName}"`);
                        }
                    }
                } catch (error) {
                    console.log('‚ùå L·ªói khi qu·∫£n l√Ω role:', error.message);
                    await interaction.followUp(`‚ö†Ô∏è Kh√¥ng th·ªÉ qu·∫£n l√Ω role: ${error.message}`);
                }

                // Build success embed
                const successEmbed = new EmbedBuilder()
                    .setTitle('üéâ ƒê·ªôt Ph√° Th√†nh C√¥ng!')
                    .setDescription(`**${interaction.user.username}** ƒë√£ ƒë·ªôt ph√° th√†nh c√¥ng!`)
                    .setColor(0x00ff00)
                    .addFields([
                        {
                            name: '‚ö° K·∫øt qu·∫£',
                            value: `‚Ä¢ **Level m·ªõi:** ${nextLevelData.name}\n‚Ä¢ **Role m·ªõi:** ${nextLevelData.role}\n‚Ä¢ **T·ªâ l·ªá th√†nh c√¥ng:** ${currentLevelData.breakRate}%`,
                            inline: false
                        }
                    ])
                    .setTimestamp()
                    .setFooter({ 
                        text: `Breakthrough ‚Ä¢ ${interaction.user.username}`, 
                        iconURL: interaction.user.displayAvatarURL() 
                    });

                if (consumedItems.length > 0) {
                    const consumedText = consumedItems.map(item => `${item.icon} ${item.name} x${item.quantity}`).join(', ');
                    successEmbed.addFields({
                        name: 'üíé V·∫≠t ph·∫©m ƒë√£ ti√™u t·ªën',
                        value: consumedText,
                        inline: false
                    });
                }

                await interaction.update({ 
                    embeds: [successEmbed], 
                    components: [] 
                });

            } else {
                // Failure - Apply penalties
                const penalty = await applyBreakthroughPenalty(client, userId, currentLevelData);

                const failureEmbed = new EmbedBuilder()
                    .setTitle('üí• ƒê·ªôt Ph√° Th·∫•t B·∫°i!')
                    .setDescription(`**${interaction.user.username}** ƒë√£ th·∫•t b·∫°i trong ƒë·ªôt ph√°!`)
                    .setColor(0xff4444)
                    .addFields([
                        {
                            name: 'üíî K·∫øt qu·∫£',
                            value: `‚Ä¢ **Level:** V·∫´n ·ªü ${cultivationUser.currentLevel}\n‚Ä¢ **T·ªâ l·ªá th√†nh c√¥ng:** ${currentLevelData.breakRate}%`,
                            inline: false
                        }
                    ])
                    .setTimestamp()
                    .setFooter({ 
                        text: `Breakthrough ‚Ä¢ ${interaction.user.username}`, 
                        iconURL: interaction.user.displayAvatarURL() 
                    });

                // Show consumed items
                if (consumedItems.length > 0) {
                    const consumedText = consumedItems.map(item => `${item.icon} ${item.name} x${item.quantity}`).join(', ');
                    failureEmbed.addFields({
                        name: 'üíé V·∫≠t ph·∫©m ƒë√£ ti√™u t·ªën',
                        value: consumedText,
                        inline: false
                    });
                }

                // Show penalties
                if (penalty.expLost > 0 || penalty.itemsLost.length > 0) {
                    let penaltyText = '';
                    if (penalty.expLost > 0) {
                        // T√≠nh % th·ª±c t·∫ø ƒë√£ m·∫•t ƒë·ªÉ hi·ªÉn th·ªã
                        const actualPercent = Math.round((penalty.expLost / (cultivationUser.exp + penalty.expLost)) * 100);
                        penaltyText += `üí∏ M·∫•t **${penalty.expLost} EXP** (${actualPercent}%)\n`;
                    }
                    if (penalty.itemsLost.length > 0) {
                        const itemsText = penalty.itemsLost.map(item => 
                            `${item.icon || '‚ùì'} ${item.name} x${item.quantity}`
                        ).join(', ');
                        penaltyText += `üóëÔ∏è M·∫•t v·∫≠t ph·∫©m: ${itemsText}`;
                    }

                    failureEmbed.addFields({
                        name: 'ü™¶ Thi·ªát h·∫°i th√™m',
                        value: penaltyText,
                        inline: false
                    });
                }

                await interaction.update({ 
                    embeds: [failureEmbed], 
                    components: [] 
                });
            }

        } catch (error) {
            console.error('Error in performBreakthrough:', error);
            await interaction.update({ 
                content: `‚ùå L·ªói ƒë·ªôt ph√°: ${error.message}`,
                embeds: [],
                components: [] 
            });
        }
    }
}; 