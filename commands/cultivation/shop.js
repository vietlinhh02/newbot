const { SHOP_ITEMS, SPIRIT_STONES, getItemStorageInfo } = require('../../utils/cultivationData');
const { EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle, ComponentType } = require('discord.js');

module.exports = {
    name: 'shop',
    aliases: ['thuongthuy', 'thuong_thuy', 'store', 'market'],
    description: 'Th∆∞∆°ng th√†nh tu ti√™n - Mua v≈© kh√≠, c√¥ng ph√°p v√† nguy√™n li·ªáu ch·∫ø t·∫°o',
    usage: '!shop ho·∫∑c !shop buy <item>',
    examples: [
        '!shop - Xem t·∫•t c·∫£ s·∫£n ph·∫©m',
        '!shop buy vk1 - Mua v≈© kh√≠',
        '!shop buy cp1 - Mua c√¥ng ph√°p'
    ],
    permissions: 'everyone',
    guildOnly: true,
    category: 'cultivation',

    async execute(message, args, client) {
        try {
            const userId = message.author.id;

            // Check if user exists
            const cultivationUser = await client.prisma.cultivationUser.findUnique({
                where: { userId: userId }
            });

            if (!cultivationUser) {
                return message.reply(`‚ùå **${message.author.username}** ch∆∞a b·∫Øt ƒë·∫ßu tu luy·ªán! G·ª≠i tin nh·∫Øn trong server ƒë·ªÉ b·∫Øt ƒë·∫ßu nh·∫≠n EXP.`);
            }

            // Handle buy command
            if (args[0] === 'buy' && args[1]) {
                return await this.handlePurchase(message, args[1], client);
            }

            // Show shop interface
            return await this.showShop(message, args[0], client);

        } catch (error) {
            console.error('Error in shop command:', error);
            await message.reply(`‚ùå L·ªói shop: ${error.message}`);
        }
    },

    async handlePurchase(message, itemId, client) {
        const userId = message.author.id;
        itemId = itemId.toLowerCase();

        // Validate item exists
        const shopItem = SHOP_ITEMS[itemId];
        if (!shopItem) {
            return message.reply(`‚ùå Kh√¥ng t√¨m th·∫•y item "${itemId}" trong shop! D√πng \`!shop\` ƒë·ªÉ xem danh s√°ch.`);
        }

        // Check if item has price (for items without price yet)
        if (!shopItem.price || !shopItem.currency) {
            return message.reply(`üí∞ **${shopItem.icon} ${shopItem.name}** hi·ªán t·∫°i ch∆∞a c√≥ gi√°! Vui l√≤ng quay l·∫°i sau.`);
        }

        // Get user inventory
        const inventory = await client.prisma.userInventory.findMany({
            where: { userId: userId }
        });

        let userCurrency = 0;
        let currencyName = '';
        let currencyIcon = '';
        
        // Handle different currency types
        if (shopItem.currency === 'exp') {
            // Get user's EXP from cultivation data
            const cultivationUser = await client.prisma.cultivationUser.findUnique({
                where: { userId: userId }
            });
            userCurrency = cultivationUser ? cultivationUser.exp : 0;
            currencyName = 'EXP';
            currencyIcon = '‚≠ê';
        } else {
            // Handle linh th·∫°ch currencies
            const currencyInfo = getItemStorageInfo(shopItem.currency);
            const currencyKey = `${currencyInfo.category}_${currencyInfo.actualId}`;
            
            const currencyItem = inventory.find(item => 
                `${item.itemType}_${item.itemId}` === currencyKey
            );
            userCurrency = currencyItem ? currencyItem.quantity : 0;
            
            const currencyData = SPIRIT_STONES[shopItem.currency];
            currencyName = currencyData.name;
            currencyIcon = currencyData.icon;
        }

        // Check if user has enough currency
        if (userCurrency < shopItem.price) {
            const errorEmbed = new EmbedBuilder()
                .setTitle('üí∏ Kh√¥ng ƒë·ªß ti·ªÅn!')
                .setDescription(`Kh√¥ng th·ªÉ mua **${shopItem.icon} ${shopItem.name}**`)
                .setColor(0xff4444)
                .addFields([
                    {
                        name: 'üí∞ Chi ph√≠',
                        value: `${currencyIcon} **${shopItem.price}** ${currencyName}`,
                        inline: true
                    },
                    {
                        name: 'üè¶ B·∫°n c√≥',
                        value: `${currencyIcon} **${userCurrency}** ${currencyName}`,
                        inline: true
                    },
                    {
                        name: '‚ùå Thi·∫øu',
                        value: `${currencyIcon} **${shopItem.price - userCurrency}** ${currencyName}`,
                        inline: true
                    }
                ])
                .setTimestamp()
                .setFooter({ 
                    text: message.author.username, 
                    iconURL: message.author.displayAvatarURL() 
                });

            return message.reply({ embeds: [errorEmbed] });
        }

        // Process purchase
        try {
            // Remove currency
            if (shopItem.currency === 'exp') {
                await client.prisma.cultivationUser.update({
                    where: { userId: userId },
                    data: { exp: { decrement: shopItem.price } }
                });
            } else {
                const currencyInfo = getItemStorageInfo(shopItem.currency);
                await client.prisma.userInventory.update({
                    where: {
                        userId_itemType_itemId: {
                            userId: userId,
                            itemType: currencyInfo.category,
                            itemId: currencyInfo.actualId
                        }
                    },
                    data: {
                        quantity: { decrement: shopItem.price }
                    }
                });
            }

            // Add purchased item
            const itemStorageInfo = getItemStorageInfo(itemId);
            await client.prisma.userInventory.upsert({
                where: {
                    userId_itemType_itemId: {
                        userId: userId,
                        itemType: itemStorageInfo.category,
                        itemId: itemStorageInfo.actualId
                    }
                },
                update: {
                    quantity: { increment: 1 }
                },
                create: {
                    userId: userId,
                    itemType: itemStorageInfo.category,
                    itemId: itemStorageInfo.actualId,
                    quantity: 1
                }
            });

            // Success message
            const successEmbed = new EmbedBuilder()
                .setTitle('üõí Mua h√†ng th√†nh c√¥ng!')
                .setDescription(`**${message.author.username}** ƒë√£ mua **${shopItem.icon} ${shopItem.name}**`)
                .setColor(0x00ff88)
                .addFields([
                    {
                        name: 'üéÅ ƒê√£ nh·∫≠n',
                        value: `${shopItem.icon} **${shopItem.name}** x1\n*${shopItem.description}*`,
                        inline: false
                    },
                    {
                        name: 'üí∞ ƒê√£ tr·∫£',
                        value: `${currencyIcon} **${shopItem.price}** ${currencyName}`,
                        inline: true
                    },
                    {
                        name: 'üè¶ C√≤n l·∫°i',
                        value: `${currencyIcon} **${userCurrency - shopItem.price}** ${currencyName}`,
                        inline: true
                    }
                ])
                .setTimestamp()
                .setFooter({ 
                    text: message.author.username, 
                    iconURL: message.author.displayAvatarURL() 
                });

            await message.reply({ embeds: [successEmbed] });

        } catch (error) {
            console.error('Error processing purchase:', error);
            await message.reply('‚ùå L·ªói x·ª≠ l√Ω giao d·ªãch! Vui l√≤ng th·ª≠ l·∫°i.');
        }
    },

    async showShop(message, category, client) {
        const userId = message.author.id;

        // Get user's currency
        const inventory = await client.prisma.userInventory.findMany({
            where: { userId: userId }
        });

        // Get user's cultivation data for EXP
        const cultivationUser = await client.prisma.cultivationUser.findUnique({
            where: { userId: userId }
        });

        const userCurrency = {};
        ['lt1', 'lt2', 'lt3', 'lt4'].forEach(ltId => {
            const currencyInfo = getItemStorageInfo(ltId);
            const key = `${currencyInfo.category}_${currencyInfo.actualId}`;
            const item = inventory.find(inv => `${inv.itemType}_${inv.itemId}` === key);
            userCurrency[ltId] = item ? item.quantity : 0;
        });
        
        // Add EXP currency
        userCurrency['exp'] = cultivationUser ? cultivationUser.exp : 0;

        // Create shop pages
        const pages = [];

        // Page 1: Overview & Balance
        const overviewEmbed = new EmbedBuilder()
            .setTitle('üè™ Th∆∞∆°ng Th√†nh Tu Ti√™n')
            .setDescription('**Mua v≈© kh√≠, c√¥ng ph√°p v√† nguy√™n li·ªáu ch·∫ø t·∫°o**')
            .setColor(0xffd700)
            .setTimestamp()
            .setFooter({ 
                text: `Trang 1/3 ‚Ä¢ ${message.author.username}`, 
                iconURL: message.author.displayAvatarURL() 
            })
            .addFields([
                {
                    name: 'üí∞ S·ªë d∆∞ c·ªßa b·∫°n',
                    value: `‚≠ê **${userCurrency.exp.toLocaleString()}** EXP\n` +
                           Object.entries(userCurrency).filter(([id]) => id !== 'exp').map(([ltId, qty]) => {
                               const ltData = SPIRIT_STONES[ltId];
                               return `${ltData.icon} **${qty.toLocaleString()}** ${ltData.name}`;
                           }).join('\n'),
                    inline: false
                },
                {
                    name: 'üõçÔ∏è Danh m·ª•c s·∫£n ph·∫©m',
                    value: '‚Ä¢ **V≈© kh√≠** ‚öîÔ∏èÔøΩÔ∏èÔøΩüî± - TƒÉng s·ª©c m·∫°nh chi·∫øn ƒë·∫•u (1000 EXP)\n' +
                           '‚Ä¢ **C√¥ng ph√°p** üìúüìÉüìãÔøΩ - TƒÉng kh·∫£ nƒÉng tu luy·ªán (1000 EXP)\n' +
                           '‚Ä¢ **ƒêan ph∆∞∆°ng & ƒêan l√≤** ÔøΩüè∫ - C·∫ßn thi·∫øt ƒë·ªÉ craft ƒëan d∆∞·ª£c üöß\n' +
                           '‚Ä¢ **T·ª• linh th·∫°ch** ÔøΩ - C·∫ßn thi·∫øt ƒë·ªÉ craft linh th·∫°ch cao üöß\n\n' +
                           'üöß **L∆∞u √Ω:** M·ªôt s·ªë items craft ƒëang ph√°t tri·ªÉn, ch∆∞a c√≥ gi√°',
                    inline: false
                },
                {
                    name: 'üéÆ C√°ch s·ª≠ d·ª•ng',
                    value: '‚Ä¢ `!shop` - Xem t·∫•t c·∫£ s·∫£n ph·∫©m\n' +
                           '‚Ä¢ `!shop buy <id>` - Mua s·∫£n ph·∫©m\n' +
                           '\n**V√≠ d·ª• mua:**\n' +
                           '‚Ä¢ `!shop buy vk1` - Mua v≈© kh√≠\n' +
                           '‚Ä¢ `!shop buy cp1` - Mua c√¥ng ph√°p\n' +
                           '\nüí° **D√πng n√∫t b√™n d∆∞·ªõi ƒë·ªÉ chuy·ªÉn trang!**',
                    inline: false
                }
            ]);
        pages.push(overviewEmbed);

        // Page 2: V≈© kh√≠ v√† C√¥ng ph√°p
        const combatEmbed = new EmbedBuilder()
            .setTitle('‚öîÔ∏è V≈© Kh√≠ & C√¥ng Ph√°p')
            .setDescription('**V≈© kh√≠ v√† c√¥ng ph√°p - mua b·∫±ng EXP ƒë·ªÉ test ƒë·ªôt ph√°**')
            .setColor(0xff0000)
            .setTimestamp()
            .setFooter({ 
                text: `Trang 2/3 ‚Ä¢ ${message.author.username}`, 
                iconURL: message.author.displayAvatarURL() 
            });

        // Add v≈© kh√≠ v√† c√¥ng ph√°p
        Object.entries(SHOP_ITEMS).filter(([id, item]) => 
            id.startsWith('vk') || id.startsWith('cp')
        ).forEach(([id, item]) => {
            const userHas = userCurrency.exp || 0;
            const canAfford = userHas >= item.price;
            
            combatEmbed.addFields({
                name: `${item.icon} ${item.name} ${canAfford ? '‚úÖ' : '‚ùå'}`,
                value: `**Gi√°:** ‚≠ê ${item.price.toLocaleString()} EXP\n` +
                       `**C√≥:** ‚≠ê ${userHas.toLocaleString()} EXP\n` +
                       `**M√¥ t·∫£:** ${item.description}\n` +
                       `**L·ªánh:** \`!shop buy ${id}\``,
                inline: true
            });
        });
        pages.push(combatEmbed);

        // Page 3: ƒêan ph∆∞∆°ng, ƒêan l√≤, T·ª• linh th·∫°ch
        const craftingEmbed = new EmbedBuilder()
            .setTitle('üîß Nguy√™n Li·ªáu Ch·∫ø T·∫°o')
            .setDescription('**ƒêan ph∆∞∆°ng, ƒëan l√≤ v√† t·ª• linh th·∫°ch - c·∫ßn thi·∫øt ƒë·ªÉ craft**')
            .setColor(0xff8800)
            .setTimestamp()
            .setFooter({ 
                text: `Trang 3/3 ‚Ä¢ ${message.author.username}`, 
                iconURL: message.author.displayAvatarURL() 
            });

        // Add ƒëan ph∆∞∆°ng, ƒëan l√≤, t·ª• linh th·∫°ch
        Object.entries(SHOP_ITEMS).filter(([id, item]) => 
            id.startsWith('dp') || id === 'pdp' || id === 'dl' || id === 'tlt'
        ).forEach(([id, item]) => {
            // Handle items without price
            if (!item.price || !item.currency) {
                craftingEmbed.addFields({
                    name: `${item.icon} ${item.name} üöß`,
                    value: `**Gi√°:** Ch∆∞a c√≥ gi√° (s·∫Øp ra m·∫Øt)\n` +
                           `**M√¥ t·∫£:** ${item.description}\n` +
                           `**Tr·∫°ng th√°i:** ƒêang ph√°t tri·ªÉn`,
                    inline: true
                });
                return;
            }

            const currencyData = SPIRIT_STONES[item.currency];
            const userHas = userCurrency[item.currency] || 0;
            const canAfford = userHas >= item.price;
            
            craftingEmbed.addFields({
                name: `${item.icon} ${item.name} ${canAfford ? '‚úÖ' : '‚ùå'}`,
                value: `**Gi√°:** ${currencyData.icon} ${item.price.toLocaleString()} ${currencyData.name}\n` +
                       `**C√≥:** ${currencyData.icon} ${userHas.toLocaleString()}\n` +
                       `**M√¥ t·∫£:** ${item.description}\n` +
                       `**L·ªánh:** \`!shop buy ${id}\``,
                inline: true
            });
        });
        pages.push(craftingEmbed);



        // Create navigation buttons
        const createButtons = (currentPage, totalPages) => {
            const buttons = [];
            
            buttons.push(
                new ButtonBuilder()
                    .setCustomId('shop_prev')
                    .setLabel('‚óÄ Tr∆∞·ªõc')
                    .setStyle(ButtonStyle.Secondary)
                    .setDisabled(currentPage === 0)
            );
            
            buttons.push(
                new ButtonBuilder()
                    .setCustomId('shop_page')
                    .setLabel(`${currentPage + 1}/${totalPages}`)
                    .setStyle(ButtonStyle.Primary)
                    .setDisabled(true)
            );
            
            buttons.push(
                new ButtonBuilder()
                    .setCustomId('shop_next')
                    .setLabel('Sau ‚ñ∂')
                    .setStyle(ButtonStyle.Secondary)
                    .setDisabled(currentPage === totalPages - 1)
            );
            
            if (currentPage !== 0) {
                buttons.push(
                    new ButtonBuilder()
                        .setCustomId('shop_home')
                        .setLabel('üè† T·ªïng quan')
                        .setStyle(ButtonStyle.Success)
                );
            }
            
            return new ActionRowBuilder().addComponents(buttons);
        };

        // Send initial message
        let currentPage = 0;
        const reply = await message.reply({ 
            embeds: [pages[currentPage]], 
            components: [createButtons(currentPage, pages.length)]
        });

        // Handle pagination
        const collector = reply.createMessageComponentCollector({
            componentType: ComponentType.Button,
            time: 300000, // 5 minutes
            filter: i => i.user.id === message.author.id
        });

        collector.on('collect', async interaction => {
            if (interaction.customId === 'shop_prev' && currentPage > 0) {
                currentPage--;
            } else if (interaction.customId === 'shop_next' && currentPage < pages.length - 1) {
                currentPage++;
            } else if (interaction.customId === 'shop_home') {
                currentPage = 0;
            }

            await interaction.update({
                embeds: [pages[currentPage]],
                components: [createButtons(currentPage, pages.length)]
            });
        });

        collector.on('end', () => {
            const disabledButtons = createButtons(currentPage, pages.length);
            disabledButtons.components.forEach(button => {
                if (!button.data.disabled) button.setDisabled(true);
            });
            
            reply.edit({ 
                embeds: [pages[currentPage]], 
                components: [disabledButtons] 
            }).catch(() => {});
        });
    }
}; 