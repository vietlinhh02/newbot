const { hasFlexiblePermission } = require('../../utils/permissions');
const embedFactory = require('../../utils/embeds');
const logger = require('../../utils/logger');
const { ActionRowBuilder, ButtonBuilder, ButtonStyle, ComponentType } = require('discord.js');

module.exports = {
    name: 'growth',
    description: 'Ph√¢n t√≠ch tƒÉng tr∆∞·ªüng th√†nh vi√™n server theo th·ªùi gian',
    aliases: ['memberstats', 'growthtats', 'memberanalytics'],
    usage: '!growth [7d|30d|90d|all]',
    category: 'advanced',
    permissions: 'admin',
    guildOnly: true,
    examples: [
        '!growth',
        '!growth 7d',
        '!growth 30d',
        '!growth all'
    ],

    async execute(message, args, client) {
        try {
            // Check permissions
            if (!await hasFlexiblePermission(message.member, 'growth', this.permissions, message.guild.id)) {
                const embed = embedFactory.error(
                    'Kh√¥ng c√≥ quy·ªÅn!',
                    'L·ªánh n√†y c·∫ßn quy·ªÅn **Administrator** ho·∫∑c cao h∆°n.'
                );
                return message.reply({ embeds: [embed] });
            }

            const period = args[0]?.toLowerCase() || '30d';
            
            switch (period) {
                case '7d':
                case '7':
                case 'week':
                    await this.showGrowth(message, 7, 'Tu·∫ßn v·ª´a qua');
                    break;
                case '30d':
                case '30':
                case 'month':
                    await this.showGrowth(message, 30, 'Th√°ng v·ª´a qua');
                    break;
                case '90d':
                case '90':
                case 'quarter':
                    await this.showGrowth(message, 90, 'Qu√Ω v·ª´a qua');
                    break;
                case 'all':
                case 'total':
                    await this.showAllTimeGrowth(message);
                    break;
                default:
                    await this.showHelp(message);
                    break;
            }

        } catch (error) {
            logger.error('Growth command error', error);
            const embed = embedFactory.error(
                'L·ªói ph√¢n t√≠ch growth!',
                'Kh√¥ng th·ªÉ t·∫°o b√°o c√°o tƒÉng tr∆∞·ªüng.',
                error.message
            );
            await message.reply({ embeds: [embed] });
        }
    },

    async showGrowth(message, days, periodName) {
        const guild = message.guild;
        
        // Loading
        const loadingEmbed = embedFactory.info(
            'üìà ƒêang ph√¢n t√≠ch growth...',
            'ƒêang t√≠nh to√°n d·ªØ li·ªáu tƒÉng tr∆∞·ªüng...'
        );
        const loadingMsg = await message.reply({ embeds: [loadingEmbed] });

        try {
            // Simulate growth data (in real app, get from database)
            const growthData = this.generateGrowthData(days);
            const currentMembers = guild.memberCount;
            
            // Calculate metrics
            const totalJoined = growthData.reduce((sum, day) => sum + day.joined, 0);
            const totalLeft = growthData.reduce((sum, day) => sum + day.left, 0);
            const netGrowth = totalJoined - totalLeft;
            const growthRate = ((netGrowth / currentMembers) * 100).toFixed(2);
            const avgJoinPerDay = (totalJoined / days).toFixed(1);
            const avgLeavePerDay = (totalLeft / days).toFixed(1);
            
            // Find best and worst days
            const bestDay = growthData.reduce((max, day) => 
                (day.joined - day.left) > (max.joined - max.left) ? day : max
            );
            const worstDay = growthData.reduce((min, day) => 
                (day.joined - day.left) < (min.joined - min.left) ? day : min
            );

            const embed = embedFactory.info(
                'üìà Member Growth Analytics',
                `**${guild.name}** - ${periodName} (${days} ng√†y)`
            );

            embed.addFields([
                {
                    name: 'üìä T·ªïng quan Growth',
                    value: `**Th√†nh vi√™n hi·ªán t·∫°i:** ${currentMembers.toLocaleString()}\n**Tham gia:** +${totalJoined}\n**R·ªùi ƒëi:** -${totalLeft}\n**TƒÉng r√≤ng:** ${netGrowth >= 0 ? '+' : ''}${netGrowth}`,
                    inline: true
                },
                {
                    name: 'üìà T·ª∑ l·ªá tƒÉng tr∆∞·ªüng',
                    value: `**Growth Rate:** ${growthRate}%\n**Trung b√¨nh/ng√†y:** +${avgJoinPerDay}\n**Churn Rate:** ${avgLeavePerDay}/ng√†y\n**Retention:** ${((totalJoined - totalLeft) / totalJoined * 100).toFixed(1)}%`,
                    inline: true
                },
                {
                    name: 'üèÜ Ng√†y t·ªët nh·∫•t',
                    value: `**Ng√†y:** ${bestDay.date}\n**Tham gia:** +${bestDay.joined}\n**R·ªùi ƒëi:** -${bestDay.left}\n**Net:** +${bestDay.joined - bestDay.left}`,
                    inline: true
                },
                {
                    name: 'üìâ Ng√†y t·ªá nh·∫•t',
                    value: `**Ng√†y:** ${worstDay.date}\n**Tham gia:** +${worstDay.joined}\n**R·ªùi ƒëi:** -${worstDay.left}\n**Net:** ${worstDay.joined - worstDay.left}`,
                    inline: true
                },
                {
                    name: 'üéØ D·ª± ƒëo√°n Growth',
                    value: `**30 ng√†y t·ªõi:** ${this.predictGrowth(growthData, 30)}\n**ƒê·∫°t 1000 members:** ${this.predictMilestone(currentMembers, growthData, 1000)}\n**Trend:** ${this.getGrowthTrend(growthData)}`,
                    inline: true
                },
                {
                    name: 'üìä Performance Score',
                    value: `**Score:** ${this.calculateGrowthScore(growthData)}/100\n**Rating:** ${this.getGrowthRating(growthData)}\n**Health:** ${this.getGrowthHealth(netGrowth, days)}`,
                    inline: true
                }
            ]);

            // Create growth chart text
            const chartData = this.createGrowthChart(growthData);
            embed.addFields([{
                name: 'üìà Growth Chart (Net members m·ªói ng√†y):',
                value: `\`\`\`${chartData}\`\`\``,
                inline: false
            }]);

            // Add period buttons
            const buttons = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('growth_7d')
                        .setLabel('üìÖ 7 ng√†y')
                        .setStyle(days === 7 ? ButtonStyle.Success : ButtonStyle.Secondary),
                    new ButtonBuilder()
                        .setCustomId('growth_30d')
                        .setLabel('üìÖ 30 ng√†y')
                        .setStyle(days === 30 ? ButtonStyle.Success : ButtonStyle.Secondary),
                    new ButtonBuilder()
                        .setCustomId('growth_90d')
                        .setLabel('üìÖ 90 ng√†y')
                        .setStyle(days === 90 ? ButtonStyle.Success : ButtonStyle.Secondary),
                    new ButtonBuilder()
                        .setCustomId('growth_all')
                        .setLabel('üìÖ All Time')
                        .setStyle(ButtonStyle.Primary)
                );

            await loadingMsg.edit({ embeds: [embed], components: [buttons] });

            // Handle button interactions
            const collector = loadingMsg.createMessageComponentCollector({
                componentType: ComponentType.Button,
                time: 300000 // 5 minutes
            });

            collector.on('collect', async (interaction) => {
                if (interaction.user.id !== message.author.id) {
                    await interaction.reply({ 
                        content: 'Ch·ªâ ng∆∞·ªùi g·ªçi l·ªánh m·ªõi c√≥ th·ªÉ s·ª≠ d·ª•ng!', 
                        ephemeral: true 
                    });
                    return;
                }

                await interaction.deferUpdate();
                
                switch (interaction.customId) {
                    case 'growth_7d':
                        await this.showGrowth(message, 7, 'Tu·∫ßn v·ª´a qua');
                        break;
                    case 'growth_30d':
                        await this.showGrowth(message, 30, 'Th√°ng v·ª´a qua');
                        break;
                    case 'growth_90d':
                        await this.showGrowth(message, 90, 'Qu√Ω v·ª´a qua');
                        break;
                    case 'growth_all':
                        await this.showAllTimeGrowth(message);
                        break;
                }
            });

            logger.command(message.author, `growth ${days}d`, message.guild);

        } catch (error) {
            logger.error('Growth analysis error', error);
            const embed = embedFactory.error(
                'L·ªói ph√¢n t√≠ch!',
                'Kh√¥ng th·ªÉ t·∫°o b√°o c√°o growth.',
                error.message
            );
            await loadingMsg.edit({ embeds: [embed] });
        }
    },

    async showAllTimeGrowth(message) {
        const guild = message.guild;
        const createdDays = Math.floor((Date.now() - guild.createdTimestamp) / (1000 * 60 * 60 * 24));
        
        const embed = embedFactory.info(
            'üöÄ All-Time Growth Analytics',
            `**${guild.name}** - T·ª´ ng√†y th√†nh l·∫≠p`
        );

        // Simulate all-time data
        const totalMembers = guild.memberCount;
        const avgGrowthPerDay = (totalMembers / createdDays).toFixed(2);
        const milestones = this.calculateMilestones(totalMembers, createdDays);

        embed.addFields([
            {
                name: 'üìä All-Time Stats',
                value: `**Server Age:** ${createdDays} ng√†y\n**Current Members:** ${totalMembers.toLocaleString()}\n**Avg Growth/Day:** ${avgGrowthPerDay}\n**Total Growth Rate:** ${((totalMembers / createdDays) * 100).toFixed(2)}%`,
                inline: true
            },
            {
                name: 'üèÜ Milestones',
                value: milestones,
                inline: true
            },
            {
                name: 'üìà Growth Phases',
                value: `**Launch Phase:** Ng√†y 1-30\n**Growth Phase:** Ng√†y 31-180\n**Mature Phase:** Ng√†y 180+\n**Current Phase:** ${this.getCurrentPhase(createdDays)}`,
                inline: true
            }
        ]);

        await message.reply({ embeds: [embed] });
    },

    async showHelp(message) {
        const embed = embedFactory.help({
            title: 'üìà Growth Analytics Help',
            description: '**Ph√¢n t√≠ch tƒÉng tr∆∞·ªüng th√†nh vi√™n server**\n\nTheo d√µi v√† ph√¢n t√≠ch xu h∆∞·ªõng tƒÉng tr∆∞·ªüng',
            categories: [
                {
                    emoji: 'üìÖ',
                    name: '7 ng√†y',
                    value: '`!growth 7d` - Growth tu·∫ßn v·ª´a qua'
                },
                {
                    emoji: 'üìÖ',
                    name: '30 ng√†y',
                    value: '`!growth 30d` - Growth th√°ng v·ª´a qua'
                },
                {
                    emoji: 'üìÖ',
                    name: '90 ng√†y',
                    value: '`!growth 90d` - Growth qu√Ω v·ª´a qua'
                },
                {
                    emoji: 'üöÄ',
                    name: 'All Time',
                    value: '`!growth all` - Growth t·ª´ khi th√†nh l·∫≠p'
                }
            ]
        });

        await message.reply({ embeds: [embed] });
    },

    // Helper functions
    generateGrowthData(days) {
        const data = [];
        for (let i = days - 1; i >= 0; i--) {
            const date = new Date(Date.now() - i * 24 * 60 * 60 * 1000);
            data.push({
                date: date.toLocaleDateString('vi-VN'),
                joined: Math.floor(Math.random() * 15) + 1,
                left: Math.floor(Math.random() * 8) + 1
            });
        }
        return data;
    },

    createGrowthChart(data) {
        const maxNet = Math.max(...data.map(d => d.joined - d.left));
        const minNet = Math.min(...data.map(d => d.joined - d.left));
        const range = maxNet - minNet || 1;
        
        const chart = data.slice(-14).map(d => {
            const net = d.joined - d.left;
            const normalized = Math.round(((net - minNet) / range) * 10);
            const bar = '‚ñà'.repeat(Math.max(1, normalized));
            return `${d.date.slice(0, 5)}: ${bar} (${net >= 0 ? '+' : ''}${net})`;
        }).join('\n');
        
        return chart;
    },

    predictGrowth(data, futureDays) {
        const avgNet = data.reduce((sum, d) => sum + (d.joined - d.left), 0) / data.length;
        const predicted = Math.round(avgNet * futureDays);
        return `${predicted >= 0 ? '+' : ''}${predicted} members`;
    },

    predictMilestone(current, data, target) {
        const avgNet = data.reduce((sum, d) => sum + (d.joined - d.left), 0) / data.length;
        if (avgNet <= 0) return 'Kh√¥ng kh·∫£ thi';
        const daysToTarget = Math.ceil((target - current) / avgNet);
        return `~${daysToTarget} ng√†y`;
    },

    getGrowthTrend(data) {
        const firstHalf = data.slice(0, Math.floor(data.length / 2));
        const secondHalf = data.slice(Math.floor(data.length / 2));
        
        const firstAvg = firstHalf.reduce((sum, d) => sum + (d.joined - d.left), 0) / firstHalf.length;
        const secondAvg = secondHalf.reduce((sum, d) => sum + (d.joined - d.left), 0) / secondHalf.length;
        
        if (secondAvg > firstAvg) return 'üìà TƒÉng';
        if (secondAvg < firstAvg) return 'üìâ Gi·∫£m';
        return '‚û°Ô∏è ·ªîn ƒë·ªãnh';
    },

    calculateGrowthScore(data) {
        const avgNet = data.reduce((sum, d) => sum + (d.joined - d.left), 0) / data.length;
        const consistency = this.calculateConsistency(data);
        return Math.min(100, Math.max(0, Math.round((avgNet * 10) + consistency)));
    },

    getGrowthRating(data) {
        const score = this.calculateGrowthScore(data);
        if (score >= 80) return 'üî• Excellent';
        if (score >= 60) return '‚úÖ Good';
        if (score >= 40) return '‚ö†Ô∏è Average';
        return 'üò¥ Poor';
    },

    getGrowthHealth(netGrowth, days) {
        const rate = netGrowth / days;
        if (rate > 5) return 'üíö R·∫•t kh·ªèe';
        if (rate > 2) return 'üíõ Kh·ªèe m·∫°nh';
        if (rate > 0) return 'üß° ·ªîn ƒë·ªãnh';
        return '‚ù§Ô∏è C·∫ßn c·∫£i thi·ªán';
    }
};
